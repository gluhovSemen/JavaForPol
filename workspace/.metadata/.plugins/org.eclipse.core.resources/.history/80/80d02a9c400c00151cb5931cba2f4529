/**  *@author ≈лизавета

 *4.  ¬ыполнить приложение командной строки с двум€ параметрами , один из которых Ц количество потоков, 
другой параметр Ц количество выводимых строк.
Ќужно так синхронизовать потоки, чтобы имена потоков выводились поочередно- в каждой строке.
ѕод синхронизацией подразумеваетс€ использование конструкции synchronized и методов wait, notify.
»спользовать ограничени€ из задани€ 3. 
»м€ первого потока должно всегда выводитс€ в новой строке. * 
 * */
 
package lab4;
public class lab4 {

    private final static class ST extends Thread {

        private Object wait;
        
        private int count;
        private int number;
        private boolean last = false;
        private int k;

        public ST(Object wait, int count, int number, int k) {
            this.wait =  wait;
            this.count = count;
            this.number = number;
            this.k=k;
        }

        @Override
        public void run() {

            for (int i=0;i<count;++i) {

                if (wait!=null && !(number==0 && i==0))
                   
                	synchronized(wait) {
                        try {if (k!=1) {   
                            wait.wait();
                        } 
                        	}catch (InterruptedException e) {
                            // TODO Auto-generated catch block
                            e.printStackTrace();
                        }
                    }

                System.out.print(this.getName()+" ");
                if (last) {
                    System.out.println("\n");
                }

                synchronized(this) { 
                    this.notify();
                }

            }
        }

    }

    public static void main(String[] args) {
        int NumberOfThreeds = Integer.parseInt(args[0]);
        int NumberOfLines = Integer.parseInt(args[1]);
        
    
        

        ST [] threads = new ST[NumberOfThreeds];
        
       
        for (int i=0;i<NumberOfThreeds;i++) {
            threads[i]= new ST(i==0?null:threads[i-1],NumberOfLines,i,NumberOfThreeds);
        }
        threads[0].wait = threads[NumberOfThreeds-1];
        threads[NumberOfThreeds-1].last = true;

        for (int i=NumberOfThreeds;i>0;i--) {
            new Thread(threads[i-1]).start();
        }

    }

}
