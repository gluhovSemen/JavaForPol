/**
 * @author Елизавета


 * Создать приложение с 2 классами- Book, Shoe  и  интерфейсом Product. Определить новый интерфейс  Present,
 расширяющий интерфейс Product и содержащий  метод it_can_be_presented(), который может возвращать строку.
Объявить 2 новых класса (например Toy, Picture), реализующих  интерфейс Present.
В приложении создать массив объектов Product-(Book, Shoe,Toy, Picture) , состоящий из количества элементов заданного параметром.
Перебирая в цикле элементы массива Product, находить  c помощью оператора  instanceof  те объекты, которые реализуют  интерфейс Present.
Для каждого найденного элемента массива Product, реализующего новый интерфейс Present, 
выполнить метод нового интерфейса it_can_be_presented(). 
 */


package shop;

import java.util.Random;

public class shop {
	static shoe cross; 
	static book note; 
	static toy bear; 
	static picture pic; 

public static void init()
{	cross=new shoe();
	note=new book();
	bear=new toy();
	pic=new picture();
	}

 public static void info(product item){
	 System.out.println("The name of shop is "  + item.NAME + " and our telephone "+ product.PHONE); 
	item.name(); 
	 System.out.println("Each item costs $" + item.cost(1)); 
	 System.out.println("---------------");
 }
	
	
 public static void main(String[] args) { 
	 if (args.length!=1) {
         System.out.printf(" ошибка-введите  параметр %d\n",
                             args.length); 
                  return;
	 }

         Integer l=0;
                
         try { l=Integer.parseInt(args[0]);  }
     		    catch(Exception e) {
                System.out.printf("параметр   %s не число \n",args[0]);
                return;
            }
         
	 init(); 
/*	 
	 info(bear); 
	   info(note);
	   info(pic);
	   info(cross);*/
	   
	Random rand = new Random();
		
	 product[] p = new product[l];
	 
		for (int i=0;i<l;i++){
			int n=rand.nextInt(3+1);
			
			switch(n) 
			{ 
			case 0: p[i]= cross; 
			break; 
			case 1: p[i]=note;
			break; 
			case 2: p[i]=bear; 
			break; 
			case 3: p[i]=pic; 
			break; 
			} 
			
			
			if(p[i] instanceof present){
				((present)p[i]).it_can_be_presented();
				info(p[i]);
				}

		}
		
			
} }
 
